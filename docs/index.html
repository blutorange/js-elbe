<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>elbe</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">elbe</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> elbe</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<p>Iterators are great, and works well with Sets and Maps, eg. <code>(new Map()).entries()</code>.
					Until I realized you can&#39;t really do much with iterators, and having to do manual iterations
					all the time is a pain. Methods and their names inspired by JavaScript, Java stream API
				and ruby&#39;s enumerables. Minified, transpiled code without browser polyfills etc. is 20 KB.</p>
				<p>Let&#39;s compare how parsing a set of JSON strings feels like with this library and vanilla JS:</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> input = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">"9"</span>,<span class="hljs-string">"9a"</span>])

<span class="hljs-comment">// Doing it with this library, returns [9,0]</span>
stream(input).try(<span class="hljs-built_in">JSON</span>.parse)
    .onError(<span class="hljs-built_in">console</span>.error)
    .orElse(<span class="hljs-number">0</span>)
    .toArray()

<span class="hljs-comment">// The same with vanilla JS, returns [9,0]</span>
<span class="hljs-built_in">Array</span>.from(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">data</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> data) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">yield</span> <span class="hljs-built_in">JSON</span>.parse(item)
        }
        <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-built_in">console</span>.error(e)
            <span class="hljs-keyword">yield</span> <span class="hljs-number">0</span>
        }
    }
}(input))
</code></pre>
				<h1 id="roadmap">Roadmap</h1>
				<ul>
					<li>IStream#rewind</li>
					<li>IStream#consume</li>
					<li>testing the API in practice, making it easier to use</li>
				</ul>
				<h1 id="docs">Docs</h1>
				<p><a href="https://blutorange.github.io/js-elbe/">All methods with documentation</a>. The entire
				public API is expressed in terms of (typescript) interfaces, these are fully documented.</p>
				<p>The docs can be viewed offline from the directory <code>docs</code>. Tests with more examples are in <code>test</code>. </p>
				<p><a href="https://blutorange.github.io/js-elbe/coverage/">Coverage report.</a></p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> lib = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>);
</code></pre>
				<p>This returns an object with the following entries:</p>
				<ul>
					<li><a href="https://blutorange.github.io/js-elbe/globals.html#collectors">Collectors</a></li>
					<li><a href="https://blutorange.github.io/js-elbe/globals.html#inplacestreamfactory">InplaceStreamFactory</a></li>
					<li><a href="https://blutorange.github.io/js-elbe/globals.html#chunk">Methods</a></li>
					<li><a href="https://blutorange.github.io/js-elbe/globals.html#monkeypatch">monkeyPatch</a></li>
					<li><a href="https://blutorange.github.io/js-elbe/globals.html#stream">stream</a></li>
					<li><a href="https://blutorange.github.io/js-elbe/globals.html#tryfactory">TryFactory</a></li>
					<li><a href="https://blutorange.github.io/js-elbe/globals.html#typesafestreamfactory">TypesafeStreamFactory</a></li>
				</ul>
				<h1 id="install">Install</h1>
				<p>You know the drill.</p>
				<pre><code class="lang-sh">npm install --save elbe
</code></pre>
				<p>Or use the standalone in <code>dist/elbe.js</code>. With node it simply exports itself, within a browser it registers globally as <code>window.Elbe</code>.</p>
				<h1 id="usage">Usage</h1>
				<p>Generates a stream of 100 numbers between 0 and 2.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> factory = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>).InplaceStreamFactory;
factory.times(<span class="hljs-number">1000</span>,<span class="hljs-number">1.4</span>,<span class="hljs-number">1.5</span>).minBy(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-built_in">Math</span>.abs(x * x - <span class="hljs-number">2</span>))
<span class="hljs-comment">// =&gt; 1.41421...</span>
</code></pre>
				<p>Generates a stream from an array.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> { stream } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>);
stream([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]).map(...).filter(...).limit(<span class="hljs-number">1</span>).group(...);
</code></pre>
				<p>The following entries exist on the <code>lib</code> object when requiring the library:</p>
				<pre><code class="lang-javascript">lib = {
    stream, <span class="hljs-comment">// shortcut for InplaceStream.from</span>
    monkeyPatch, <span class="hljs-comment">// function that patches some Object prototypes</span>
    InplaceStreamFactory: { <span class="hljs-comment">// see interface 'StreamFactory'</span>
      <span class="hljs-keyword">from</span>,
      times,
      ...
    }
    TypesafeStreamFactory: { <span class="hljs-comment">// see interface 'StreamFactory'</span>
      <span class="hljs-keyword">from</span>,
      times,
      ...
    },
    TryFactory, <span class="hljs-comment">// see interface 'ITryFactory'</span>
    Collectors: { <span class="hljs-comment">// all methods documented in 'Collectors'</span>
        join,
        group,
        ...
    },
    <span class="hljs-attr">Methods</span>: { <span class="hljs-comment">// contains all methods documented in 'Methods'</span>
        filter, 
        group,
        map,
        ...
    }
}
</code></pre>
				<p>There are three different ways of using the stream methods:</p>
				<h2 id="standalone-functions">Standalone functions</h2>
				<p>All methods are available as stand-alone functions taking an
				iterable as their first argument.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> { Collectors, <span class="hljs-attr">Methods</span>: {map, filter, collect} } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>);

<span class="hljs-keyword">const</span> iterable = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];

map(iterable, x =&gt; <span class="hljs-number">2</span>*x); <span class="hljs-comment">// =&gt; Iterable[2,4,6]</span>

filter(iterable, x =&gt; x &gt; <span class="hljs-number">2</span>); <span class="hljs-comment">// =&gt; Iterable[4,6]</span>

collect(iterable, Collectors.join()); <span class="hljs-comment">// =&gt; "4,6"</span>
</code></pre>
				<h2 id="stream-wrapper">Stream wrapper</h2>
				<p>For easier chaining, there are also two wrapper classes
				available for the stand-alone functions.</p>
				<p>The inplace stream comes with less overhead, but is not typesafe.
				This is most likely irrelevant unless you are using TypeScript.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> { stream } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>);

stream([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]).map(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span><span class="hljs-number">2</span>*x).filter(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span>x&gt;<span class="hljs-number">2</span>).concat([<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]).join(<span class="hljs-string">","</span>);
<span class="hljs-comment">// =&gt; "4,6,7,9"</span>
</code></pre>
				<p>The typesafe streams creates a new wrapper instance when
				chaining for type safety. The overhead should not be large.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> stream = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>).TypesafeStreamFactory.stream;

stream([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]).map(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span><span class="hljs-number">2</span>*x).filter(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span>x&gt;<span class="hljs-number">2</span>).concat([<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]).join(<span class="hljs-string">","</span>);
<span class="hljs-comment">// =&gt; "4,6,7,9"</span>
</code></pre>
				<p>Once a stream was chained (consumed), it must not be used anymore,
				or an error is thrown:</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> stream = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>).TypesafeStreamFactory.stream;

<span class="hljs-keyword">const</span> s = stream([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);

s.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * x); <span class="hljs-comment">// =&gt; Stream[1,4,9]</span>

<span class="hljs-comment">// Error: "Stream was already consumed."</span>
s.filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">2</span>);
</code></pre>
				<p>Similarly for inplace streams: </p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> stream = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>).InplaceStreamFactory.stream;

<span class="hljs-keyword">const</span> s = stream([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);

s.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * x); <span class="hljs-comment">// =&gt; Stream[2,4,6]</span>

s.filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">2</span>); <span class="hljs-comment">// =&gt; Stream[4,6]</span>

s.join() <span class="hljs-comment">// =&gt; "46"</span>

s.join() <span class="hljs-comment">// Error: "Stream was already consumed."</span>
</code></pre>
				<h2 id="monkey-patching">Monkey patching</h2>
				<p>I would not recommend it, but you can monkey-patch a <code>stream</code> method to some objects.
				May be helpful for testing or prototyping.</p>
				<pre><code class="lang-javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>).monkeypatch();

[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].stream().map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">4</span>).toSet();
<span class="hljs-comment">// =&gt; Set[5,6,7]</span>

<span class="hljs-string">"foobar"</span>.stream().filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-string">"d"</span>).toArray();
<span class="hljs-comment">// =&gt; ["f", "o", "o", "r"]</span>

<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]).stream();
<span class="hljs-comment">// =&gt; Stream[1,2,3]</span>

<span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([<span class="hljs-string">"foo"</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">"bar"</span>, <span class="hljs-number">9</span>]).stream();
<span class="hljs-comment">// =&gt; Stream[ ["foo", 3], ["bar", 9] ]</span>

({<span class="hljs-attr">foo</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">bar</span>: <span class="hljs-number">9</span>}).stream();
<span class="hljs-comment">// =&gt; Stream[ {key: "foo", value: 3}], {key: "bar", value: 9} ]</span>
</code></pre>
				<h1 id="catching-errors">Catching errors</h1>
				<p>Use the <code>try</code> method to handle errors during stream operations.</p>
				<pre><code class="lang-javascript">stream(json1, json2, json3).try(<span class="hljs-built_in">JSON</span>.parse);

<span class="hljs-comment">// same as the above</span>
stream(json1, json2, json3).map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> lib.TryFactory.of(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">JSON</span>.parse(x)))
</code></pre>
				<p>This returns a stream with <code>Try</code> objects encapsulating the error, if one occured.</p>
				<p>To get the values of the successful operations:</p>
				<pre><code class="lang-javascript"><span class="hljs-comment">// Logs errors to the console, removes them from the stream, and</span>
<span class="hljs-comment">// returns successfully parsed JSON objects.</span>
stream(json1, json2, json3).try(<span class="hljs-built_in">JSON</span>.parse).discardError().toArray()
</code></pre>
				<p>To get the values of the successful and failed operations:</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> result = stream(json1, json2, json3).try(<span class="hljs-built_in">JSON</span>.parse).partition(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.success);

result.false.forEach(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> { ... }) <span class="hljs-comment">// do something with the errors</span>

result.true.forEach(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> { ... }) <span class="hljs-comment">// do something with the succesful values</span>
</code></pre>
				<p>To provide a default for failed operations:</p>
				<pre><code class="lang-javascript">stream(json1, json2, json3).try(<span class="hljs-built_in">JSON</span>.parse).map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.orElse(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// JSON object or undefined.</span>
</code></pre>
				<h1 id="changelog">Changelog</h1>
				<h2 id="0-2-0">0.2.0</h2>
				<ul>
					<li>Fixed Collectors.averageGeometrically, which returned the wrong result.</li>
					<li>Fixed a bug with ITry#convert and ITry#flatConvert when called on a successful ITry without a backup.</li>
					<li>Fixed some typings.</li>
					<li>Changed Collectors.summarize to return NaN for average, min, max, sum, variance. when there are no items. </li>
					<li>Changed Collectors.sum, Collectors.average, Collectors.averageGeometrically Collectors.averageHarmonically to return <code>NaN</code> when there are no items.</li>
					<li>Changed the name of Collectors.factor to Collectors.multiply. This matches the naming
					convention of Collectors.sum.</li>
					<li>Changed Collectors.toMap so that when two items have the same key, it takes the
						first (not last) encountered item and adds it to the map for that key. This makes
					it consistent with IStream#unique that also takes the first value.</li>
					<li>Added optionality to the error handler parameter of ITry#then, it is now optional.</li>
					<li>Added an optional paramter to Collectors.multiply for specifying how to convert
					the items into numbers.</li>
					<li>Added the method Collectors.map(mapper, downstream).</li>
					<li>Added an optional merge function to Collector.toMap and IStream#toMap.</li>
					<li>Improved performance of Collectors.groupDown and Collectors.partitionDown by
					not creating an unneccessary temporary array.</li>
					<li>Documented Collectors.</li>
					<li>Added second set of tests. Tests now cover the code.</li>
				</ul>
				<h2 id="0-1-4">0.1.4</h2>
				<ul>
					<li>Fixed typings for IStream#toMap and added type parameter to IStream#uniqueBy, IStream#minBy and IStream#maxBy</li>
					<li>Fixed IStreamFactory#repeat(item, amount) to default to Infinity when the second argument is not given.</li>
					<li>Fixed #IStream#times when called with arguments (Infinity, 0, 10) to return a stream of unlimited <code>0</code>s. `times(Infinity, 0, 10) means infinitely many items between 0 and 10, ie. separated by an infinitesimal step.</li>
					<li>Fixed a bug where ITry#success returned true for an erronous result.</li>
					<li>Fixed ITryStream#include that would not exclude the items that did not match the predicate.</li>
					<li>Fixed IStream#nth(n) so that it immediately returns on numbers smaller than 0. If a non-integer is given, floors it.</li>
					<li>Changed ITry#convert(converter, backup) and ITry#flatConvert so that it applies the backup in case the converter threw an error.</li>
					<li>Changed IStream#max(comparator) and IStreamFactory#min(comparator) to make the comparator optional, default to the natural comparator.</li>
					<li>Changed IStream#uniqueBy so that it consumes the iterable only on-demand. This allows it to work with infinite streams: <code>stream([1,2,3].cycle(Infinity)).uniqueBy().limit(2)</code>. Note that this still enters a never-ending loop when not called with a limit or a too-high limit, as it needs to keep scanning the stream for elements that are potentially new.</li>
					<li>The IStreamFactory.fromObject now returns a stream of objects {key, value} instead of [key, value].</li>
					<li>Added IStrem#none(Predicate), returning true iff no item matches the given predicate.</li>
					<li>Added IStreamFactory#step(amount, start, step), which is similar to IStreamFactory#times, but allows specifying the step directly.</li>
					<li>Added first set of tests.</li>
				</ul>
				<h2 id="0-1-3">0.1.3</h2>
				<ul>
					<li>The IStream#index method now returns a stream of objects {index, value}. Previously it returned a stream of array [index, value]. Named keys are easier to work with than integer keys. Performance wise, arrays are only objects, and objects with fixed keys can be optimized.</li>
				</ul>
				<h2 id="0-1-2">0.1.2</h2>
				<ul>
					<li>The IStream#fork method now works with streams of unlimited length. This is achieved by querying and buffering the original stream only when needed.</li>
				</ul>
				<h1 id="build">Build</h1>
				<p>Make sure you fetch all dependencies</p>
				<pre><code class="lang-sh">npm install
</code></pre>
				<p>Then run</p>
				<pre><code class="lang-sh">npm run build
</code></pre>
				<p>This may fail on Windows, who but a rabbit knows...</p>
				<h1 id="teh-name">Teh name</h1>
				<p>Many a barrel of water streams, but never rolls, down the <a href="https://en.wikipedia.org/wiki/Elbe">Elbe river</a>.</p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-class tsd-has-type-parameter tsd-is-private">
						<a href="classes/abstractstream.html" class="tsd-kind-icon">Abstract<wbr>Stream</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter tsd-is-not-exported">
						<a href="classes/basetryimpl.html" class="tsd-kind-icon">Base<wbr>Try<wbr>Impl</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter tsd-is-not-exported">
						<a href="classes/failureimpl.html" class="tsd-kind-icon">Failure<wbr>Impl</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/inplacestream.html" class="tsd-kind-icon">Inplace<wbr>Stream</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/lazybufferediterable.html" class="tsd-kind-icon">Lazy<wbr>Buffered<wbr>Iterable</a>
					</li>
					<li class=" tsd-kind-class tsd-is-not-exported">
						<a href="classes/statisticsimpl.html" class="tsd-kind-icon">Statistics<wbr>Impl</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter tsd-is-not-exported">
						<a href="classes/successimpl.html" class="tsd-kind-icon">Success<wbr>Impl</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter tsd-is-not-exported">
						<a href="classes/trystreamimpl.html" class="tsd-kind-icon">Try<wbr>Stream<wbr>Impl</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/typesafestream.html" class="tsd-kind-icon">Typesafe<wbr>Stream</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/icollector.html" class="tsd-kind-icon">ICollector</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/icollectors.html" class="tsd-kind-icon">ICollectors</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/istatistics.html" class="tsd-kind-icon">IStatistics</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/istream.html" class="tsd-kind-icon">IStream</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/istreamfactory.html" class="tsd-kind-icon">IStream<wbr>Factory</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/itry.html" class="tsd-kind-icon">ITry</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/itryfactory.html" class="tsd-kind-icon">ITry<wbr>Factory</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/itrystream.html" class="tsd-kind-icon">ITry<wbr>Stream</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter tsd-is-not-exported">
						<a href="interfaces/iuniqueentry.html" class="tsd-kind-icon">IUnique<wbr>Entry</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#biconsumer" class="tsd-kind-icon">Bi<wbr>Consumer</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#bifunction" class="tsd-kind-icon">Bi<wbr>Function</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#bipredicate" class="tsd-kind-icon">Bi<wbr>Predicate</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#binaryoperator" class="tsd-kind-icon">Binary<wbr>Operator</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#consumer" class="tsd-kind-icon">Consumer</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#function" class="tsd-kind-icon">Function</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#maybe" class="tsd-kind-icon">Maybe</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#predicate" class="tsd-kind-icon">Predicate</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#supplier" class="tsd-kind-icon">Supplier</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#inplacestreamfactory" class="tsd-kind-icon">Inplace<wbr>Stream<wbr>Factory</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#typesafestreamfactory" class="tsd-kind-icon">Typesafe<wbr>Stream<wbr>Factory</a>
					</li>
					<li class=" tsd-kind-variable tsd-is-not-exported">
						<a href="globals.html#hasownproperty" class="tsd-kind-icon">has<wbr>Own<wbr>Property</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#stream" class="tsd-kind-icon">stream</a>
					</li>
					<li class=" tsd-kind-function tsd-is-not-exported">
						<a href="globals.html#appendcause" class="tsd-kind-icon">append<wbr>Cause</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#chunk" class="tsd-kind-icon">chunk</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#collect" class="tsd-kind-icon">collect</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#collectwith" class="tsd-kind-icon">collect<wbr>With</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#concat" class="tsd-kind-icon">concat</a>
					</li>
					<li class=" tsd-kind-function tsd-is-not-exported">
						<a href="globals.html#createfactory" class="tsd-kind-icon">create<wbr>Factory</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#cycle" class="tsd-kind-icon">cycle</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#end" class="tsd-kind-icon">end</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#every" class="tsd-kind-icon">every</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#filter" class="tsd-kind-icon">filter</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#find" class="tsd-kind-icon">find</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#findindex" class="tsd-kind-icon">find<wbr>Index</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#first" class="tsd-kind-icon">first</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#flatmap" class="tsd-kind-icon">flat<wbr>Map</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#fork" class="tsd-kind-icon">fork</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#fromobject" class="tsd-kind-icon">from<wbr>Object</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#fromobjectkeys" class="tsd-kind-icon">from<wbr>Object<wbr>Keys</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#fromobjectvalues" class="tsd-kind-icon">from<wbr>Object<wbr>Values</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#generate" class="tsd-kind-icon">generate</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#group" class="tsd-kind-icon">group</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#has" class="tsd-kind-icon">has</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter tsd-is-not-exported">
						<a href="globals.html#identity" class="tsd-kind-icon">identity</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#index" class="tsd-kind-icon">index</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter tsd-is-not-exported">
						<a href="globals.html#istry" class="tsd-kind-icon">is<wbr>Try</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#iterate" class="tsd-kind-icon">iterate</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#join" class="tsd-kind-icon">join</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#last" class="tsd-kind-icon">last</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#limit" class="tsd-kind-icon">limit</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter tsd-is-not-exported">
						<a href="globals.html#make" class="tsd-kind-icon">make</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#map" class="tsd-kind-icon">map</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#max" class="tsd-kind-icon">max</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#maxby" class="tsd-kind-icon">max<wbr>By</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#min" class="tsd-kind-icon">min</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#minby" class="tsd-kind-icon">min<wbr>By</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#monkeypatch" class="tsd-kind-icon">monkey<wbr>Patch</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#none" class="tsd-kind-icon">none</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#nth" class="tsd-kind-icon">nth</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#partition" class="tsd-kind-icon">partition</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter tsd-is-not-exported">
						<a href="globals.html#patch" class="tsd-kind-icon">patch</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#promise" class="tsd-kind-icon">promise</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#reduce" class="tsd-kind-icon">reduce</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#reducesame" class="tsd-kind-icon">reduce<wbr>Same</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#repeat" class="tsd-kind-icon">repeat</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#reverse" class="tsd-kind-icon">reverse</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#size" class="tsd-kind-icon">size</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#skip" class="tsd-kind-icon">skip</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#slice" class="tsd-kind-icon">slice</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#some" class="tsd-kind-icon">some</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#sort" class="tsd-kind-icon">sort</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#step" class="tsd-kind-icon">step</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#sum" class="tsd-kind-icon">sum</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter tsd-is-not-exported">
						<a href="globals.html#takefirst" class="tsd-kind-icon">take<wbr>First</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#times" class="tsd-kind-icon">times</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#toarray" class="tsd-kind-icon">to<wbr>Array</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#tomap" class="tsd-kind-icon">to<wbr>Map</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter tsd-is-not-exported">
						<a href="globals.html#tonumber" class="tsd-kind-icon">to<wbr>Number</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#toset" class="tsd-kind-icon">to<wbr>Set</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#trycompute" class="tsd-kind-icon">try<wbr>Compute</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#tryend" class="tsd-kind-icon">try<wbr>End</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#trymap" class="tsd-kind-icon">try<wbr>Map</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#unique" class="tsd-kind-icon">unique</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#uniqueby" class="tsd-kind-icon">unique<wbr>By</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#visit" class="tsd-kind-icon">visit</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#zip" class="tsd-kind-icon">zip</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#zipsame" class="tsd-kind-icon">zip<wbr>Same</a>
					</li>
					<li class=" tsd-kind-object-literal">
						<a href="globals.html#collectors" class="tsd-kind-icon">Collectors</a>
					</li>
					<li class=" tsd-kind-object-literal">
						<a href="globals.html#tryfactory" class="tsd-kind-icon">Try<wbr>Factory</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>
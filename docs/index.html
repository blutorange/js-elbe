<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>elbe</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">elbe</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> elbe</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<p>Iterators are great, and work well with Sets and Maps, eg. <code>(new Map()).entries()</code>.
					Until I realized you can&#39;t really do much with iterators, and having to do manual
					iterations all the time is a pain. Methods and their names inspired by JavaScript,
					Java stream API and ruby&#39;s enumerables. Minified, transpiled code without browser
				polyfills etc. is 20 KB, and around ~7 KB gzipped.</p>
				<p>Let&#39;s compare how parsing a set of JSON strings feels like with this library and vanilla JS:</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> input = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">"9"</span>,<span class="hljs-string">"9a"</span>])
<span class="hljs-keyword">const</span> { stream } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>);

<span class="hljs-comment">// Doing it with this library, returns [9,0]</span>
stream(input).try(<span class="hljs-built_in">JSON</span>.parse)
    .onError(<span class="hljs-built_in">console</span>.error)
    .orElse(<span class="hljs-number">0</span>)
    .toArray()

<span class="hljs-comment">// The same with vanilla JS, returns [9,0]</span>
<span class="hljs-built_in">Array</span>.from(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">data</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> data) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">yield</span> <span class="hljs-built_in">JSON</span>.parse(item)
        }
        <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-built_in">console</span>.error(e)
            <span class="hljs-keyword">yield</span> <span class="hljs-number">0</span>
        }
    }
}(input))
</code></pre>
				<h1 id="roadmap">Roadmap</h1>
				<ul>
					<li>investigate a IStream#rewind method. IStream#fork already serves this purpose.</li>
					<li>testing the API in practice, making it easier to use</li>
				</ul>
				<h1 id="versioning">Versioning</h1>
				<p>This is currently in version 0.x. Once this package is used by other packages other than my own, the version will be
				increased to 1.0 and start using <a href="https://semver.org/">semantic versioning</a>.</p>
				<h1 id="docs">Docs</h1>
				<p><a href="https://blutorange.github.io/js-elbe/">All methods with documentation</a>.</p>
				<p>The entire public API is expressed in terms of (typescript) interfaces, these
				are fully documented.</p>
				<p>The docs can be viewed offline from the directory <code>docs</code>. Tests with more examples are in <code>test</code>. </p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> lib = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>);
</code></pre>
				<p>This returns an object with the following entries:</p>
				<ul>
					<li><a href="https://blutorange.github.io/js-elbe/globals.html#collectors">Collectors</a></li>
					<li><a href="https://blutorange.github.io/js-elbe/globals.html#inplacestreamfactory">InplaceStreamFactory</a></li>
					<li><a href="https://blutorange.github.io/js-elbe/globals.html#appendCause">Methods</a></li>
					<li><a href="https://blutorange.github.io/js-elbe/globals.html#monkeypatch">monkeyPatch</a></li>
					<li><a href="https://blutorange.github.io/js-elbe/globals.html#stream">stream</a></li>
					<li><a href="https://blutorange.github.io/js-elbe/globals.html#tryfactory">TryFactory</a></li>
					<li><a href="https://blutorange.github.io/js-elbe/globals.html#typesafestreamfactory">TypesafeStreamFactory</a></li>
				</ul>
				<p>The <a href="https://blutorange.github.io/js-elbe/interfaces/istream.html">IStream</a> contains all the juicy methods you want. A stream is created by an <a href="https://blutorange.github.io/js-elbe/globals.html#inplacestreamfactory">InplaceStreamFactory</a>, accessible via <code>require(&quot;elbe&quot;).factory</code>. Read
				below for further details.</p>
				<p><a href="https://blutorange.github.io/js-elbe/coverage/">Coverage report.</a></p>
				<h1 id="install">Install</h1>
				<p>You know the drill.</p>
				<pre><code class="lang-sh">npm install --save elbe
</code></pre>
				<p>Then load it</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> { stream, factory } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>);
<span class="hljs-comment">// or</span>
<span class="hljs-keyword">import</span> { stream, factory } <span class="hljs-keyword">from</span> <span class="hljs-string">"elbe"</span>;
</code></pre>
				<p>Or use the standalone in <code>dist/elbe.js</code> that includes all required npm libraries and
				was transformed with babel. Within a browser it registers globally as <code>window.Elbe</code>.</p>
				<h1 id="usage">Usage</h1>
				<p>You can create a stream either from an iterable source such as an array
					or a <code>Set</code>; or use one of the factory methods such as <code>times</code> or <code>random</code>.
					The created stream then provides several methods such as <code>map</code> or <code>collect</code>
				to operate on its items.</p>
				<p>Generate a stream of 100 numbers between 1 and 100 and sums them, as fast as Gauss.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> factory = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>).factory;
factory.times(<span class="hljs-number">100</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100</span>).sum()
<span class="hljs-comment">// =&gt; 5050</span>
</code></pre>
				<p>Generate numbers between 1.4 and 1.5, and take the one whose square is closest to 2.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> factory = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>).factory;
factory.times(<span class="hljs-number">1000</span>,<span class="hljs-number">1.4</span>,<span class="hljs-number">1.5</span>).minBy(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-built_in">Math</span>.abs(x * x - <span class="hljs-number">2</span>))
<span class="hljs-comment">// =&gt; 1.41421...</span>
</code></pre>
				<p>Generate a stream from an array.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> { stream } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>);
stream([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]).map(...).filter(...).limit(<span class="hljs-number">1</span>).group(...);
</code></pre>
				<p>The following entries exist on the object when requiring the library:</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> lib = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>);
lib = {
    stream, <span class="hljs-comment">// shortcut for InplaceStreamFactory.stream</span>
    factory, <span class="hljs-comment">// shortcut for InplaceStreamFactory</span>
    monkeyPatch, <span class="hljs-comment">// function that patches some Object prototypes</span>
    InplaceStreamFactory: { <span class="hljs-comment">// see interface 'StreamFactory'</span>
      stream,
      times,
      generate,
      ...
    }
    TypesafeStreamFactory: { <span class="hljs-comment">// see interface 'StreamFactory'</span>
      <span class="hljs-keyword">from</span>,
      times,
      generate,
      ...
    },
    TryFactory, <span class="hljs-comment">// see interface 'ITryFactory'</span>
    Collectors: { <span class="hljs-comment">// see interface 'ICollectors'</span>
        join,
        group,
        ...
    },
    <span class="hljs-attr">Methods</span>: { <span class="hljs-comment">// contains all methods documented in 'Methods'</span>
        filter, 
        group,
        map,
        ...
    }
}
</code></pre>
				<p>There are three different ways of using the stream methods:</p>
				<h2 id="standalone-functions">Standalone functions</h2>
				<p>All methods are available as stand-alone functions taking an
				iterable as their first argument.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> { Collectors, <span class="hljs-attr">Methods</span>: {map, filter, collect} } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>);

<span class="hljs-keyword">const</span> iterable = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];

map(iterable, x =&gt; <span class="hljs-number">2</span>*x); <span class="hljs-comment">// =&gt; Iterable[2,4,6]</span>

filter(iterable, x =&gt; x &gt; <span class="hljs-number">2</span>); <span class="hljs-comment">// =&gt; Iterable[4,6]</span>

collect(iterable, Collectors.join()); <span class="hljs-comment">// =&gt; "4,6"</span>
</code></pre>
				<p>All factory methods for creating streams are also available:</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-attr">Methods</span>: {times} } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>);
times(<span class="hljs-number">10</span>).map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i + <span class="hljs-number">1</span>).toArray()
<span class="hljs-comment">// =&gt; [1,2,3,4,5,6,7,8,9,10]</span>
</code></pre>
				<h2 id="stream-wrapper">Stream wrapper</h2>
				<p>For easier chaining, there are also two wrapper classes
				available for the stand-alone functions.</p>
				<p>The inplace stream comes with less overhead, but is not typesafe.
				This is most likely irrelevant unless you are using TypeScript.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> { stream } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>);

stream([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]).map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-number">2</span>*x).filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">2</span>).concat([<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]).join(<span class="hljs-string">","</span>);
<span class="hljs-comment">// =&gt; "4,6,7,9"</span>
</code></pre>
				<p>The typesafe streams creates a new wrapper instance when
				chaining for type safety. The overhead should not be large.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> stream = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>).TypesafeStreamFactory.stream;

stream([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]).map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-number">2</span>*x).filter(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span>x&gt;<span class="hljs-number">2</span>).concat([<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]).join(<span class="hljs-string">","</span>);
<span class="hljs-comment">// =&gt; "4,6,7,9"</span>
</code></pre>
				<p>Once a stream was chained (consumed), it must not be used anymore,
				or an error is thrown:</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> stream = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>).TypesafeStreamFactory.stream;

<span class="hljs-keyword">const</span> s = stream([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);

s.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * x); <span class="hljs-comment">// =&gt; Stream[1,4,9]</span>

<span class="hljs-comment">// Error: "Stream was already consumed."</span>
s.filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">2</span>);
</code></pre>
				<p>Similarly for inplace streams: </p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> stream = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>).InplaceStreamFactory.stream;

<span class="hljs-keyword">const</span> s = stream([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);

s.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * x); <span class="hljs-comment">// =&gt; Stream[2,4,6]</span>

s.filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">2</span>); <span class="hljs-comment">// =&gt; Stream[4,6]</span>

s.join() <span class="hljs-comment">// =&gt; "46"</span>

s.join() <span class="hljs-comment">// Error: "Stream was already consumed."</span>
</code></pre>
				<h3 id="unlimited-streams">Unlimited streams</h3>
				<p>Stream can be of unlimited (<code>infinite</code>) length, one common example are generators
				such as random number generators:</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-attr">InplaceStreamFactory</span>: factory } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>);
<span class="hljs-keyword">const</span> unlimitedStream = factory.generate(<span class="hljs-built_in">Math</span>.random);
</code></pre>
				<p>Methods operating on streams try to read only as many items from the stream
					as required. This means you can create chains of stream operations on unlimited
					streams and not have it hang, as long as the terminal operation does not request
				all items. For example:</p>
				<pre><code class="lang-javascript"><span class="hljs-comment">// Returns the first item</span>
factory.generate(<span class="hljs-built_in">Math</span>.random)
  .map(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span><span class="hljs-number">10</span>*x)
  .filter(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span>x&gt;<span class="hljs-number">5</span>)
  .first();

<span class="hljs-comment">// Returns the first 20 items.</span>
factory.generate(<span class="hljs-built_in">Math</span>.random)
  .map(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span><span class="hljs-number">10</span>*x)
  .filter(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span>x&gt;<span class="hljs-number">5</span>)
  .limit(<span class="hljs-number">20</span>)
  .toArray()

<span class="hljs-comment">// Returns the first 20 items and leaves the stream open so</span>
<span class="hljs-comment">// that you can read more items from it later.</span>
factory.generate(<span class="hljs-built_in">Math</span>.random)
  .map(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span><span class="hljs-number">10</span>*x)
  .filter(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span>x&gt;<span class="hljs-number">5</span>)
  .splice(<span class="hljs-number">20</span>)
</code></pre>
				<p>A notable example that always needs to read the entire stream is <code>IStream#reverse</code>.
					Filtering the stream for uniqueness with <code>IStream#unique</code> and <code>IStream#uniqueBy</code>
				supports unlimited stream.s</p>
				<h3 id="note-for-typescript-users">Note for typescript users</h3>
				<p>Some methods from <code>IStream</code> have the special return type <code>this</code>. They DO NOT
					return the same object; but rather <code>this</code> is used to indicate that the returned
					stream is of the same type as the stream on which the method was called. This allows
					the typescript compiler to infer that a subclass of <code>IStream</code> remains as such even
				when calling methods from the super type. To illustrate:</p>
				<pre><code class="lang-javascript"><span class="hljs-comment">// s is now of type IStream&lt;number&gt;</span>
s = stream([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])

<span class="hljs-comment">// s is now a ITryStream&lt;number&gt; with some additional methods</span>
s = s.try(<span class="hljs-comment">/*something dangerous*/</span>)

<span class="hljs-comment">// `limit` is a method from IStream&lt;T&gt;, and without the `this` return</span>
<span class="hljs-comment">// type, s would be downgraded to a normal stream, losing all additional</span>
<span class="hljs-comment">// methods from ITryStream&lt;T&gt;.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// s is still of type ITryStream&lt;number&gt;, but may be a different</span>
<span class="hljs-comment">// instance than before. For this to work with the typescript compile,</span>
<span class="hljs-comment">// the return type is required to be `this`.</span>
s = s.limit(<span class="hljs-number">2</span>)
</code></pre>
				<h2 id="monkey-patching">Monkey patching</h2>
				<p>I would not recommend it, but you can monkey-patch a <code>stream</code> method to some objects.
				May be helpful for testing or prototyping.</p>
				<pre><code class="lang-javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>).monkeypatch();

[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].stream().map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">4</span>).toSet();
<span class="hljs-comment">// =&gt; Set[5,6,7]</span>

<span class="hljs-string">"foobar"</span>.stream().filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-string">"d"</span>).toArray();
<span class="hljs-comment">// =&gt; ["f", "o", "o", "r"]</span>

<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]).stream();
<span class="hljs-comment">// =&gt; Stream[1,2,3]</span>

<span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([<span class="hljs-string">"foo"</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">"bar"</span>, <span class="hljs-number">9</span>]).stream();
<span class="hljs-comment">// =&gt; Stream[ ["foo", 3], ["bar", 9] ]</span>

({<span class="hljs-attr">foo</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">bar</span>: <span class="hljs-number">9</span>}).stream();
<span class="hljs-comment">// =&gt; Stream[ {key: "foo", value: 3}], {key: "bar", value: 9} ]</span>
</code></pre>
				<h1 id="catching-errors">Catching errors</h1>
				<p>Use the <code>try</code> method to handle errors during stream operations.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> { stream, TryFactory } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"elbe"</span>);
stream([json1, json2, json3]).try(<span class="hljs-built_in">JSON</span>.parse);

<span class="hljs-comment">// The same effect could be achieved by mapping each item manually</span>
stream([json1, json2, json3]).map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> lib.TryFactory.of(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">JSON</span>.parse(x)))
</code></pre>
				<p>This returns a stream with <code>Try</code> objects encapsulating the error, if one occured.</p>
				<p>To get the values of the successful operations:</p>
				<pre><code class="lang-javascript"><span class="hljs-comment">// Logs errors to the console, removes them from the stream, and</span>
<span class="hljs-comment">// returns successfully parsed JSON objects.</span>
stream([json1, json2, json3]).try(<span class="hljs-built_in">JSON</span>.parse).discardError().toArray()
</code></pre>
				<p>To get the values of the successful and failed operations:</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> result = stream([json1, json2, json3]).try(<span class="hljs-built_in">JSON</span>.parse).partition(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.success);
<span class="hljs-comment">// do something with the errors</span>
result.false.forEach(<span class="hljs-function"><span class="hljs-params">errorTry</span> =&gt;</span> { ... })
<span class="hljs-comment">// do something with the succesful values</span>
result.true.forEach(<span class="hljs-function"><span class="hljs-params">valueTry</span> =&gt;</span> { ... })

<span class="hljs-comment">// Alternatively, call an error/success handler</span>
<span class="hljs-keyword">const</span> s = stream([json1, json2, json3]).try(<span class="hljs-built_in">JSON</span>.parse)
s.then(<span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> {<span class="hljs-comment">/* success handler*/</span>}, error =&gt; {<span class="hljs-comment">/*error handler*/</span>})
</code></pre>
				<p>To provide a default for failed operations:</p>
				<pre><code class="lang-javascript">stream(json1, json2, json3).try(<span class="hljs-built_in">JSON</span>.parse).orElse(<span class="hljs-literal">undefined</span>);
<span class="hljs-comment">// JSON object or undefined.</span>
</code></pre>
				<h1 id="changelog">Changelog</h1>
				<p>I use the following keywords:</p>
				<ul>
					<li><code>Added</code> A new feature that is backwards-compatible.</li>
					<li><code>Changed</code> A change that is not backwards-compatible.</li>
					<li><code>Fixed</code> A bug or error that was fixed.</li>
				</ul>
				<h2 id="0-4-0-work-in-progress-">0.4.0 (work-in-progress)</h2>
				<ul>
					<li>Added methods <code>IStream#isEmpty</code> and <code>IStream#isSizeBetween</code>.</li>
					<li>Added method <code>IStream#slice</code> that works like <code>IStream#splice</code>, but does not remove the items from the stream.</li>
					<li>Changed method <code>IStream#splice</code> and exchanged the <code>offset</code> and <code>maxAmount</code> parameters to bring it in line with how <code>Array#splice</code> works. This also resulted in the same change for method <code>IStream#consume</code>.</li>
					<li>Changed the named of method <code>IStream#slice</code> to <code>chunk</code>, to avoid confusion with JavaScript&#39;s method <code>Array#slice</code>. The former method <code>IStream#chunk</code> is now called <code>IStream#chunkBy</code>.</li>
					<li>Changed: Extracted common interfaces and types to their own package. If you are using typescript and are referring to these types explicity, change the import statement from <code>elbe</code> to <code>andross</code>.</li>
					<li>Fixed method <code>IStream#skip</code> when used with infinite stream and passed <code>Infinity</code>. This skips all items and returns an empty stream.</li>
				</ul>
				<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> { Consumer, Predicate, <span class="hljs-comment">/*...*/</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"elbe"</span>;
<span class="hljs-comment">// change to</span>
<span class="hljs-keyword">import</span> { Consumer, Predicate, <span class="hljs-comment">/*...*/</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"andross"</span>;
</code></pre>
				<h2 id="0-3-0">0.3.0</h2>
				<ul>
					<li>Changed IStream#unique so that the single parameter <code>keyExtractor</code> is required. Not passing this parameter is equivalent to using IStream#unique with no parameters.</li>
					<li>Added method IStreamFactory#filterBy</li>
					<li>Added method IStreamFactory#sortBy</li>
					<li>Added possibility for Methods.concat to take 0 iterables instead of at least 1.</li>
					<li>Fixed typing for Methods.minBy, Methods.maxBy, Methods.uniqueBy</li>
				</ul>
				<h2 id="0-2-1">0.2.1</h2>
				<ul>
					<li>Added method IStreamFactory#empty</li>
					<li>Added a shortcut for InplaceStreamFactory, <code>require(&quot;elbe&quot;).factory</code></li>
				</ul>
				<h2 id="0-2-0">0.2.0</h2>
				<ul>
					<li>Fixed ICollectors.averageGeometrically, which returned the wrong result.</li>
					<li>Fixed a bug with ITry#convert and ITry#flatConvert when called on a successful ITry without a backup.</li>
					<li>Fixed some typings.</li>
					<li>Changed the behaviour of IStream#limit and other methods expecting an integer argument to a more sane behaviour when a floating point number is given. </li>
					<li>Changed ICollectors.summarize to return NaN for average, min, max, sum, variance. when there are no items. </li>
					<li>Changed ICollectors.sum, Collectors.average, ICollectors.averageGeometrically ICollectors.averageHarmonically to return <code>NaN</code> when there are no items.</li>
					<li>Changed the name of Collectors.factor to Collectors.multiply. This matches the naming
					convention of Collectors.sum.</li>
					<li>Changed ICollectors.toMap so that when two items have the same key, it takes the
						first (not last) encountered item and adds it to the map for that key. This makes
					it consistent with IStream#unique that also takes the first value.</li>
					<li>Changed IStream#unique to process items only as requested. This makes it work with unlimited streams when limited afterwards. This is achieved with a <a href="https://www.npmjs.com/package/bintrees">balanced binary tree</a> when a comparator is given, and a Set otherwise.</li>
					<li>Changed IStream#cycle to buffer the items lazily. This makes it work with unlimited
					streams when limited afterwards.</li>
					<li>Added a method ICollectors.random. This is not cryptographically secure.</li>
					<li>Added optionality to the error handler parameter of ITry#then, it is now optional.</li>
					<li>Added optionality to the <code>skip</code> parameter of ITry#skip, it is now optional. If not
					given, skips no items.</li>
					<li>Added optionality to the <code>limit</code> parameter of ITry#skip, it is now optional. If not
					given, apply no limit.</li>
					<li>Added an optional paramter to Collectors.multiply for specifying how to convert
					the items into numbers.</li>
					<li>Added the method Collectors.map(mapper, downstream).</li>
					<li>Added an optional merge function to Collector.toMap and IStream#toMap.</li>
					<li>Improved performance of Collectors.groupDown and Collectors.partitionDown by
					not creating an unneccessary temporary array.</li>
					<li>Documented Collectors.</li>
					<li>Added second set of tests.</li>
				</ul>
				<h2 id="0-1-4">0.1.4</h2>
				<ul>
					<li>Fixed typings for IStream#toMap and added type parameter to IStream#uniqueBy, IStream#minBy and IStream#maxBy</li>
					<li>Fixed IStreamFactory#repeat(item, amount) to default to Infinity when the second argument is not given.</li>
					<li>Fixed #IStream#times when called with arguments (Infinity, 0, 10) to return a stream of unlimited <code>0</code>s. `times(Infinity, 0, 10) means infinitely many items between 0 and 10, ie. separated by an infinitesimal step.</li>
					<li>Fixed a bug where ITry#success returned true for an erronous result.</li>
					<li>Fixed ITryStream#include that would not exclude the items that did not match the predicate.</li>
					<li>Fixed IStream#nth(n) so that it immediately returns on numbers smaller than 0. If a non-integer is given, floors it.</li>
					<li>Changed ITry#convert(converter, backup) and ITry#flatConvert so that it applies the backup in case the converter threw an error.</li>
					<li>Changed IStream#max(comparator) and IStreamFactory#min(comparator) to make the comparator optional, default to the natural comparator.</li>
					<li>Changed IStream#uniqueBy so that it consumes the iterable only on-demand. This allows it to work with infinite streams: <code>stream([1,2,3].cycle(Infinity)).uniqueBy().limit(2)</code>. Note that this still enters a never-ending loop when not called with a limit or a too-high limit, as it needs to keep scanning the stream for elements that are potentially new.</li>
					<li>The IStreamFactory.fromObject now returns a stream of objects {key, value} instead of [key, value].</li>
					<li>Added Methods.fromIter() that takes an iterable or an iterator and returns an iterable.</li>
					<li>Added IStream.consume(sink, maxAmount, offset) that consumes the given amount of items, writes them to the sink and returns a stream over the remaining items.</li>
					<li>Added IStream#shift and IStream#splice that return the first item or the first few items from the stream, but leave the stream open for further consumption of the remaining items. </li>
					<li>Added IStrem#none(Predicate), returning true iff no item matches the given predicate.</li>
					<li>Added IStreamFactory#step(amount, start, step), which is similar to IStreamFactory#times, but allows specifying the step directly.</li>
					<li>Added first set of tests.</li>
				</ul>
				<h2 id="0-1-3">0.1.3</h2>
				<ul>
					<li>The IStream#index method now returns a stream of objects {index, value}. Previously it returned a stream of array [index, value]. Named keys are easier to work with than integer keys. Performance wise, arrays are only objects, and objects with fixed keys can be optimized.</li>
				</ul>
				<h2 id="0-1-2">0.1.2</h2>
				<ul>
					<li>The IStream#fork method now works with streams of unlimited length. This is achieved by querying and buffering the original stream only when needed.</li>
				</ul>
				<h1 id="build">Build</h1>
				<p>Make sure you fetch all dependencies</p>
				<pre><code class="lang-sh">npm install
</code></pre>
				<p>Then run</p>
				<pre><code class="lang-sh">npm run build
</code></pre>
				<p>This may fail on Windows, who but a rabbit knows...</p>
				<h1 id="teh-name">Teh name</h1>
				<p>Many a barrel of water streams, but never rolls, down the <a href="https://en.wikipedia.org/wiki/Elbe">Elbe river</a>.</p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-class tsd-has-type-parameter tsd-is-private">
						<a href="classes/abstractstream.html" class="tsd-kind-icon">Abstract<wbr>Stream</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter tsd-is-not-exported">
						<a href="classes/basetryimpl.html" class="tsd-kind-icon">Base<wbr>Try<wbr>Impl</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter tsd-is-not-exported">
						<a href="classes/failureimpl.html" class="tsd-kind-icon">Failure<wbr>Impl</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/inplacestream.html" class="tsd-kind-icon">Inplace<wbr>Stream</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/lazybufferediterable.html" class="tsd-kind-icon">Lazy<wbr>Buffered<wbr>Iterable</a>
					</li>
					<li class=" tsd-kind-class tsd-is-not-exported">
						<a href="classes/statisticsimpl.html" class="tsd-kind-icon">Statistics<wbr>Impl</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter tsd-is-not-exported">
						<a href="classes/successimpl.html" class="tsd-kind-icon">Success<wbr>Impl</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter tsd-is-not-exported">
						<a href="classes/trystreamimpl.html" class="tsd-kind-icon">Try<wbr>Stream<wbr>Impl</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/typesafestream.html" class="tsd-kind-icon">Typesafe<wbr>Stream</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/icollectors.html" class="tsd-kind-icon">ICollectors</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/iforkedresult.html" class="tsd-kind-icon">IForked<wbr>Result</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/istatistics.html" class="tsd-kind-icon">IStatistics</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/istream.html" class="tsd-kind-icon">IStream</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/istreamfactory.html" class="tsd-kind-icon">IStream<wbr>Factory</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/itry.html" class="tsd-kind-icon">ITry</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/itryfactory.html" class="tsd-kind-icon">ITry<wbr>Factory</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/itrystream.html" class="tsd-kind-icon">ITry<wbr>Stream</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#inplacestreamfactory" class="tsd-kind-icon">Inplace<wbr>Stream<wbr>Factory</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#typesafestreamfactory" class="tsd-kind-icon">Typesafe<wbr>Stream<wbr>Factory</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#factory" class="tsd-kind-icon">factory</a>
					</li>
					<li class=" tsd-kind-variable tsd-is-not-exported">
						<a href="globals.html#hasownproperty" class="tsd-kind-icon">has<wbr>Own<wbr>Property</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#stream" class="tsd-kind-icon">stream</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#appendcause" class="tsd-kind-icon">append<wbr>Cause</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#chunk" class="tsd-kind-icon">chunk</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#chunkby" class="tsd-kind-icon">chunk<wbr>By</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#collect" class="tsd-kind-icon">collect</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#collectwith" class="tsd-kind-icon">collect<wbr>With</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#concat" class="tsd-kind-icon">concat</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#consume" class="tsd-kind-icon">consume</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#consumefirst" class="tsd-kind-icon">consume<wbr>First</a>
					</li>
					<li class=" tsd-kind-function tsd-is-not-exported">
						<a href="globals.html#createfactory" class="tsd-kind-icon">create<wbr>Factory</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#cycle" class="tsd-kind-icon">cycle</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#end" class="tsd-kind-icon">end</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#every" class="tsd-kind-icon">every</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#filter" class="tsd-kind-icon">filter</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#filterby" class="tsd-kind-icon">filter<wbr>By</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#find" class="tsd-kind-icon">find</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#findindex" class="tsd-kind-icon">find<wbr>Index</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#first" class="tsd-kind-icon">first</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#flatmap" class="tsd-kind-icon">flat<wbr>Map</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#fork" class="tsd-kind-icon">fork</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#fromiter" class="tsd-kind-icon">from<wbr>Iter</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#fromobject" class="tsd-kind-icon">from<wbr>Object</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#fromobjectkeys" class="tsd-kind-icon">from<wbr>Object<wbr>Keys</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#fromobjectvalues" class="tsd-kind-icon">from<wbr>Object<wbr>Values</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#generate" class="tsd-kind-icon">generate</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#group" class="tsd-kind-icon">group</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#has" class="tsd-kind-icon">has</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#identity" class="tsd-kind-icon">identity</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#index" class="tsd-kind-icon">index</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#isempty" class="tsd-kind-icon">is<wbr>Empty</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#issizebetween" class="tsd-kind-icon">is<wbr>Size<wbr>Between</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter tsd-is-not-exported">
						<a href="globals.html#istry" class="tsd-kind-icon">is<wbr>Try</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#iterate" class="tsd-kind-icon">iterate</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#join" class="tsd-kind-icon">join</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#last" class="tsd-kind-icon">last</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#limit" class="tsd-kind-icon">limit</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter tsd-is-not-exported">
						<a href="globals.html#make" class="tsd-kind-icon">make</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#map" class="tsd-kind-icon">map</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#max" class="tsd-kind-icon">max</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#maxby" class="tsd-kind-icon">max<wbr>By</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#min" class="tsd-kind-icon">min</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#minby" class="tsd-kind-icon">min<wbr>By</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#monkeypatch" class="tsd-kind-icon">monkey<wbr>Patch</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#none" class="tsd-kind-icon">none</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#nth" class="tsd-kind-icon">nth</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#partition" class="tsd-kind-icon">partition</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter tsd-is-not-exported">
						<a href="globals.html#patch" class="tsd-kind-icon">patch</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#promise" class="tsd-kind-icon">promise</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#random" class="tsd-kind-icon">random</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#reduce" class="tsd-kind-icon">reduce</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#reducesame" class="tsd-kind-icon">reduce<wbr>Same</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#repeat" class="tsd-kind-icon">repeat</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#reverse" class="tsd-kind-icon">reverse</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#size" class="tsd-kind-icon">size</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#skip" class="tsd-kind-icon">skip</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#slice" class="tsd-kind-icon">slice</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#some" class="tsd-kind-icon">some</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#sort" class="tsd-kind-icon">sort</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#sortby" class="tsd-kind-icon">sort<wbr>By</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#splice" class="tsd-kind-icon">splice</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#step" class="tsd-kind-icon">step</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#sum" class="tsd-kind-icon">sum</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#takefirst" class="tsd-kind-icon">take<wbr>First</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#times" class="tsd-kind-icon">times</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#toarray" class="tsd-kind-icon">to<wbr>Array</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#tomap" class="tsd-kind-icon">to<wbr>Map</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#tonumber" class="tsd-kind-icon">to<wbr>Number</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#toset" class="tsd-kind-icon">to<wbr>Set</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#trycompute" class="tsd-kind-icon">try<wbr>Compute</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#tryend" class="tsd-kind-icon">try<wbr>End</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#trymap" class="tsd-kind-icon">try<wbr>Map</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#unique" class="tsd-kind-icon">unique</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#uniqueby" class="tsd-kind-icon">unique<wbr>By</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#visit" class="tsd-kind-icon">visit</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#wrapiterator" class="tsd-kind-icon">wrap<wbr>Iterator</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#zip" class="tsd-kind-icon">zip</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#zipsame" class="tsd-kind-icon">zip<wbr>Same</a>
					</li>
					<li class=" tsd-kind-object-literal">
						<a href="globals.html#collectors" class="tsd-kind-icon">Collectors</a>
					</li>
					<li class=" tsd-kind-object-literal">
						<a href="globals.html#done_result" class="tsd-kind-icon">DONE_<wbr>RESULT</a>
					</li>
					<li class=" tsd-kind-object-literal">
						<a href="globals.html#empty_iterable" class="tsd-kind-icon">EMPTY_<wbr>ITERABLE</a>
					</li>
					<li class=" tsd-kind-object-literal">
						<a href="globals.html#empty_iterator" class="tsd-kind-icon">EMPTY_<wbr>ITERATOR</a>
					</li>
					<li class=" tsd-kind-object-literal">
						<a href="globals.html#tryfactory" class="tsd-kind-icon">Try<wbr>Factory</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>
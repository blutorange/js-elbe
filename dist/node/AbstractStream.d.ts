import { Comparator } from "kagura";
import { BiConsumer, BiFunction, BiPredicate, Consumer, Function, ICollector, IStream, ITry, ITryStream, Predicate, Supplier } from "./Interfaces";
export declare abstract class AbstractStream<T> implements IStream<T> {
    protected iterable: Iterable<T>;
    private done;
    constructor(iterable: Iterable<T>);
    [Symbol.iterator](): Iterator<T>;
    collect<S, R = S>(collector: ICollector<T, S, R>): R;
    collectWith<S, R = S>(supplier: Supplier<S>, accumulator: BiConsumer<S, T>, finisher: Function<S, R>): R;
    end(): void;
    every(predicate: Predicate<T>): boolean;
    find(predicate: BiPredicate<T, number>): T | undefined;
    findIndex(predicate: BiPredicate<T, number>): number;
    first(): T | undefined;
    forEach(consumer: Consumer<T>): void;
    fork(): this;
    group<K>(classifier: Function<T, K>): Map<K, T[]>;
    has(object: T): boolean;
    join(delimiter?: string, prefix?: string, suffix?: string): string;
    last(): T | undefined;
    nth(n: number): T | undefined;
    max(comparator?: Comparator<T>): T | undefined;
    maxBy<K = any>(sortKey: Function<T, K>): T | undefined;
    min(comparator?: Comparator<T>): T | undefined;
    minBy<K = any>(sortKey: Function<T, K>): T | undefined;
    partition(predicate: Predicate<T>): {
        false: T[];
        true: T[];
    };
    reduce<S>(reducer: BiFunction<S, T, S>, initialValue: S): S;
    reduceSame(reducer: BiFunction<T, T, T>): T;
    size(): number;
    some(predicate: Predicate<T>): boolean;
    sum(converter?: Function<T, number>): number;
    toArray(fresh?: boolean): T[];
    toSet(fresh?: boolean): Set<T>;
    toJSON(): T[];
    toString(): string;
    toMap<K, V>(keyMapper: Function<T, K>, valueMapper: Function<T, V>): Map<K, V>;
    tryCompute<S>(operation: Function<IStream<T>, S>): ITry<S>;
    tryEnd(): ITry<void>;
    abstract chunk<K = any>(classifier: BiFunction<T, number, K>): IStream<T[]>;
    abstract concat(...iterables: Iterable<T>[]): this;
    abstract cycle(count?: number): this;
    abstract flatMap<S>(mapper: Function<T, Iterable<S>>): IStream<S>;
    abstract filter(predicate: Predicate<T>): this;
    abstract index(): IStream<{
        index: number;
        value: T;
    }>;
    abstract limit(limitTo: number): this;
    abstract map<S>(mapper: Function<T, S>): IStream<S>;
    abstract promise<S>(promiseConverter: Function<T, Promise<S>>): Promise<IStream<S>>;
    abstract reverse(): this;
    abstract skip(toSkip: number): this;
    abstract slice(sliceSize: number): IStream<T[]>;
    abstract sort(comparator?: Comparator<T>): this;
    abstract try<S>(operation: Function<T, S>): ITryStream<S>;
    abstract unique(comparator?: Comparator<T>): this;
    abstract uniqueBy(keyExtractor?: Function<T, any>): this;
    abstract visit(consumer: Consumer<T>): this;
    abstract zip<S>(other: Iterable<S>): IStream<[T, S]>;
    abstract zipSame(...others: Iterable<T>[]): IStream<T[]>;
    protected abstract clone(iterable: Iterable<T>): this;
    protected check(): void;
}
